{"pages":[],"posts":[{"title":"ECMAScript6笔记","text":"###变量:var 全局作用域(非跨域),可重复定义,存在变量升级(var shouldn’t be used in ES6) let,const块作用域 不可重复定义.(代替立即执行函数).声明之前使用会报暂时性死区错误(use const by defualt/only use let if rebinding is needed) const不可重新赋值,属性值可修改.属性值固定可使用:Object.freeze(O); 关于 es6的 let 特性在 for 循环结构 的个人理解:https://www.jianshu.com/p/8f890da2d8bc ###箭头函数: 1234567891011121314151617const numbers=[5,6,7,8]; const double =numbers.map(function(number,i){ return `${i}: ${number * 2}`; });//箭头函数,单参数()可省略const double2 =numbers.map((number,i) =&gt; { return `${i}: ${number * 2}`;});//箭头函数隐式返回const double3 =numbers.map((number,i) =&gt; `${i}: ${number * 2}`);console.log(double3);//匿名函数const greet= name =&gt; {alert(`Hello ${name}`)}greet(\"mike\"); 函数独立运行,没有通过call,apply,bind改变this值,则独立函数中的this指向window/global/(严格模式)undefined想让函数的this值绑定定义时的父级作用域的this值,并且不希望this调用时被改变,可以使用箭头函数的写法: 1234567891011121314const Jelly={ name: 'Jelly', hobbies: ['Coding','Sleeping','Reading'], printHobbies:function(){ // let self=this; // this.hobbies.map(function(hobby){ this.hobbies.map(hobby =&gt; { // console.log(`${self.name} loves ${hobby}`) //使用函数且未指定self,则this指向window console.log(`${this.name} loves ${hobby}`) }) }}Jelly.printHobbies(); ###函数参数默认值 123456//multiply();multiply(2,);multiply(undefined,) 前项不能为空,可设a为undefinedfunction multiply(a = 5,b = 3){ /* a = a || 5; b = b || 3; */ return a * b;}","link":"/2019/08/05/ECMAScript6/"},{"title":"apache同一ip部署多个项目配置不同域名","text":"服务器环境由wamp搭建,假定wamp安装在C盘根目录下 1.进入apache配置目录配置监听端口,修改httpd文件,新增端口监听,并开启vhosts配置及允许外部访问vi C:\\wamp\\bin\\apache\\apache2.4.23\\conf\\httpd 1234567Listen 0.0.0.0:80 Listen [::0]:80Listen 0.0.0.0:4700Listen [::0]:4700# Virtual hostsInclude conf/extra/httpd-vhosts.conf 2.修改httpd-vhosts文件,配置项目及域名vi C:\\wamp\\bin\\apache\\apache2.4.23\\conf\\extra\\httpd-vhosts &lt;VirtualHost 目标域名1&gt; ServerName 目标域名1:80 ServerAlias 别名 DocumentRoot c:/wamp/www &lt;Directory \"c:/wamp/www/\"&gt; Options +Indexes +Includes +FollowSymLinks +MultiViews AllowOverride All Require all granted &lt;/Directory&gt; &lt;/VirtualHost&gt; &lt;VirtualHost 目标域名2&gt; ServerName 目标域名2:4700 ServerAlias 别名 DocumentRoot c:/wamp/项目2 &lt;Directory \"c:/wamp/项目2\"&gt; Options +Indexes +Includes +FollowSymLinks +MultiViews AllowOverride All Require all granted &lt;/Directory&gt; &lt;/VirtualHost&gt; 端口及授权部分存有疑问","link":"/2019/08/03/apacheDeploy/"},{"title":"实用工具","text":"截图工具: FSCapture pdf阅读: Adobe Acrobat DC chrome: onetab(标签组)","link":"/2019/08/02/Utilities/"},{"title":"phpFunction","text":"函数 var_dump() 显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。 print_r var_dump返回表达式的类型与值而print_r仅返回结果 fopen fopen() 函数打开一个文件或 URL。如果 fopen() 失败，它将返回 FALSE 并附带错误信息 mixed constant(string constant_name) 获取常量值 bool defined(string constants_name) 判断常量是否被定义 unset() 用于销毁给定的变量 error_reporting() 设置当前脚本的错误报告级别(返回旧的错误报告级别) memory_get_usage() 获取内存消耗 ceil() 返回数字的上入整数 file_get_contents(); 文件读取函数 ###方法:重载:方法的重载通过call来实现，当调用不存在的方法的时候，将会转为参数调用call方法，当调用不存在的静态方法时会使用__callStatic重载。 12345public function __call($name, $args) { if ($name == 'speedUp') { $this-&gt;speed += 10; }} 对象复制:在一些特殊情况下，可以通过关键字clone来复制一个对象，这时__clone方法会被调用，通过这个魔术方法来设置属性的值。 1234567891011121314class Car { public $name = 'car'; public function __clone() { $obj = new Car(); $obj-&gt;name = $this-&gt;name; }}$a = new Car();$a-&gt;name = 'new car';$b = clone $a;if ($a == $b) echo '=='; //trueif ($a === $b) echo '==='; //false 对象序列化: 123$a = new Car();$str = serialize($a); //对象序列化成字符串$b = unserialize($str); //反序列化为对象","link":"/2019/08/09/phpFunction/"},{"title":"php运算符","text":"1.字符串连接符: “.”、“.=”(连接赋值运算符):将右边参数附加到左边的参数后 2.赋值运算符:分’=’和’&amp;’ &amp;为引用赋值,共用一块内存 3.比较运算符:PHP存在 ‘===’ ‘&lt;&gt;’ ‘!==’,数字字符串可与数字变量作比较 4.逻辑运算符:&nbsp;&nbsp;&nbsp;&nbsp;与:’and,&amp;&amp;’&nbsp;&nbsp;&nbsp;&nbsp;或:’or,&verbar;&verbar;’&nbsp;&nbsp;&nbsp;&nbsp;异或:’xor’(有且仅有一个为true),&nbsp;&nbsp;&nbsp;&nbsp;非:’!’&nbsp;&nbsp;&nbsp;&nbsp;and、or、xor优先级低于三元运算符 5.错误控制运算符‘@’:&nbsp;&nbsp;&nbsp;&nbsp;对于一些可能会在运行过程中出错的表达式时，我们不希望出错的时候给客户显示错误信息，这样对用户不友好。于是，可以将@放置在一个PHP表达式之前，该表达式可能产生的任何错误信息都被忽略掉；&nbsp;&nbsp;&nbsp;&nbsp;如果激活了track_error（这个玩意在php.ini中设置）特性，表达式所产生的任何错误信息都被存放在变量$php_errormsg中，此变量在每次出错时都会被覆盖，所以如果想用它的话必须尽早检查;&nbsp;&nbsp;&nbsp;&nbsp;‘@’不会屏蔽解析错误的信息，不能把它放在函数或类的定义之前，也不能用于条件结构例如if和foreach等。","link":"/2019/08/07/phpOperator/"},{"title":"principle","text":"综合分析眼前的形势: 你能做的最重要的决定之一是决定问谁 不要听到什么信什么 所有东西都是放在眼前看更大 不要夸大新东西的好处 不要过分分析细节 综合分析变化中的形势 始终记住改善事物的速度和水平，以及两者的关系。 不必过于精确 谨记“80/20法则”，并明白关键性的“20%”是什么 不要做完美主义者 5.6 根据预期价值计算做决策 a.不管你押对的概率已经有多大，提高你的押对概率始终有价值 b.知道什么时候不要去押注，和知道什么注值得押同样重要 c.最好的选择是好处多于坏处的选择，不是毫无坏处的选择 5.7 比较更多信息带来的价值和不做决定造成的成本，决定优先顺序 a.先把你的“必做之事”做完，再做你的“想做之事” b.你很可能没有时间处理不重要的事，那最好将它留着，以免自己没有时间处理重要的事。 c.不要把概率当作可能性。 要明白几乎所有“眼前的情况”都是“类似情境的再现”，要识别“类似情境”是什么，然后应用经深思熟虑得出的原则来应对。 情景再现 a.让你的思维慢下来，以注意到你正在引用的决策标准 b.把这个标准作为一项原则写下来 c.当结果出现时，评估结果，思考标准，并在下一个“类似情境”出现之前改进标准","link":"/2019/08/05/principle/"},{"title":"php备忘","text":"tip 1.注释语句写在之间 2.变量定义:$var.使用时需要带$符 3.”echo”指令输出布尔类型时，如果是“true”则输出的是“1”，“false”则什么也不输出 4.当双引号中包含变量($)时，变量会与双引号中的内容连接在一起；当单引号中包含变量($)时，变量会被当做字符串输出。 5.Heredoc字符串结构:以&lt;&lt;&lt;标识符起始,以标识符;结束,结尾处必须另起一行且无标识符;外其他字符 for循环不需要声明变量类型 foreach:&nbsp;&nbsp;&nbsp;&nbsp;foreach (数组 as 值)&nbsp;&nbsp;&nbsp;&nbsp;foreach (数组 as 下标($key) =&gt; 值) 创建数组:$arr=array(); 分索引数组及关联数组(以字符串为key) 类使用class开头,通过new实例化,通过-&gt;获取属性.具有权限属性 方法:&nbsp;&nbsp;&nbsp;&nbsp;声明 function xxx(){};&nbsp;&nbsp;&nbsp;&nbsp;静态方法操作符为’::’,$this伪变量不允许使用。可以使用self(::)，parent，static在内部调用静态方法与属性。;&nbsp;&nbsp;&nbsp;&nbsp;construct()构造函数;&nbsp;&nbsp;&nbsp;&nbsp;parent::construct()调用父类构造函数&nbsp;&nbsp;&nbsp;&nbsp;析构函数 __destruct() &nbsp;&nbsp;&nbsp;&nbsp;可将类名函数名赋给变量动态调用 常量:1bool define ( string $name , mixed $value [, bool $case_insensitive = false ] ) 常量为全局的且使用时不带$符 系统常量: _FILE_ php程序文件名 _LINE_ 当前代码行数 PHP_VERSION 当前解析器的版本号 PHP_OS 执行当前PHP版本的操作系统名称 cookie: 参数 name（ Cookie名）可以通过$_COOKIE[‘name’] 进行访问 value（Cookie的值） expire（过期时间）Unix时间戳格式，默认为0，表示浏览器关闭即失效 path（有效路径）如果路径设置为’/‘，则整个网站都有效,设定了其他路径之后，则只在设定的路径以及子路径下有效 domain（有效域）默认整个域名都有效，如果设置了’www.xxx.com',则只在www子域中有效 PHP中还有一个设置Cookie的函数setrawcookie，setrawcookie跟setcookie基本一样，唯一的不同就是value值不会自动的进行urlencode，因此在需要的时候要手动的进行urlencode。 因为Cookie是通过HTTP标头进行设置的，所以也可以直接使用header方法进行设置。 1header(\"Set-Cookie:cookie_name=value\"); //删除cookie setcookie('test', '', time()-1); //通过header来删除cookie header(\"Set-Cookie:test=1393832059; expires=\".gmdate('D, d M Y H:i:s \\G\\M\\T', time()-1)); session:&emsp;在PHP中使用session非常简单，先执行session_start方法开启session，然后通过全局变量$_SESSION进行session的读写。&emsp;session会自动的对要设置的值进行encode与decode，因此session可以支持任意数据类型，包括数据与对象等。&emsp;默认情况下，session是以文件形式存储在服务器上的，因此当一个页面开启了session之后，会独占这个session文件，这样会导致当前用户的其他并发访问无法执行而等待。可以采用缓存或者数据库的形式存储来解决这个问题 &emsp;删除某个session值可以使用PHP的unset函数,删除后就会从全局变量$_SESSION中去除，无法访问。 &emsp;如果要删除所有的session，可以使用session_destroy函数销毁当前session，session_destroy会删除所有数据，但是session_id仍然存在。&emsp;值得注意的是，session_destroy并不会立即的销毁全局变量$_SESSION中的值，只有当下次再访问的时候,该变量才为空,需要立即销毁可以使用unset函数。&emsp;如果需要同时销毁cookie中的session_id，通常在用户退出的时候可能会用到，则还需要显式的调用setcookie方法删除session_id的cookie值。","link":"/2019/08/07/phpStart/"}],"tags":[{"name":"ECMAScript6","slug":"ECMAScript6","link":"/tags/ECMAScript6/"},{"name":"apache","slug":"apache","link":"/tags/apache/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"读书笔记","slug":"读书笔记","link":"/tags/读书笔记/"},{"name":"原则","slug":"原则","link":"/tags/原则/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"杂项","slug":"杂项","link":"/categories/杂项/"},{"name":"PHP","slug":"PHP","link":"/categories/PHP/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/读书笔记/"}]}